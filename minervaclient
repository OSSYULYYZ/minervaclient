#!/usr/bin/env python

import reg,sched,transcript
from minerva_common import *
import config,credentials_local


import argparse,sys,json
state = {}

def parse_reg(subp):
	parser = subp.add_parser('reg',help='Register for a set of courses')
	parser.add_argument("-t","--term",help="The term (e.g. FALL2016, 201609, etc.) in which to register for these courses",required=True)
	parser.add_argument("-j","--job",help="A unique name used to track which CRNs remain to be registered for (for automation purposes)")
	parser.add_argument("-A","--require-all",help="Only register for courses if all of the requested courses are available. NOTE: Only allowed when course codes are given.",action="store_true")
	parser.add_argument("-R","--require-reg",help="Only register for courses if you can enter the class or the waitlist. NOTE: Only allowed when course codes are given..",action="store_true")
	parser.add_argument("-n","--no-register",help="Don't actually perform registration.",action="store_true")
	parser.add_argument("-P","--public-search",help="[BUGGY] Do not log into Minerva to search !!! This option can only be used to register for the waitlist !!!",action="store_true")
	parser.add_argument("-v", "--verbose", help="[TODO] Show details about the HTTP requests sent to Minerva",action="store_true")
	parser.add_argument("-q","--quiet",help="[TODO] Only print output for successful registration",action="store_true")
	parser.add_argument('course',nargs='+',help="A series of CRNs (e.g. 814 202) or course codes (POLI-244-001 COMP-251-002), but not both.")
	parser.set_defaults(which='reg')

def parse_sched(subp):
	parser = subp.add_parser('sched',help='Display your course schedule')
	parser.add_argument("-t","--term",help="The term (e.g. FALL2016, 201609, etc.) for which to display the schedule",required=True)
	parser.add_argument("-D","--diff-set",help="[TODO] Monitor the requested report for any changes compared with the previous reports in the diff set")
	parser.add_argument("-r","--report",help="Choose which schedule report to display (see config.py to configure")
	parser.add_argument("-l","--long",help="Show a detailed report of the schedule",action="store_true")
	parser.add_argument("-s","--short",help="Show a brief report of the schedule",action="store_true")
	parser.add_argument("-V","--visual",help="Export a visual course timetable",action="store_true")
	parser.add_argument("-C","--calendar",help="Export a calendar containing the course schedule",action="store_true")
	parser.add_argument("--conflicts-only",help="Only show course conflicts",action="store_true")
	parser.add_argument("--no-conflicts",help="Don't show course conflicts",action="store_true")
	parser.add_argument("-f","--format",help="[TODO] Choose text format for the displayed report")
	parser.add_argument("-v", "--verbose", help="[TODO] Show details about the HTTP requests sent to Minerva",action="store_true")
	parser.set_defaults(which='sched')

def parse_transcript(subp):
	parser = subp.add_parser('transcript',help='Display your transcript')
	parser.add_argument("-t","--term",help="The term or terms, separated by commas for which to display the transcript. If no term is specified, records from all terms will be displayed")
	parser.add_argument("-D","--diff-set",help="[TODO] Monitor the requested report for any changes compared with the previous reports in the diff set")
	parser.add_argument("-r","--report",help="Choose which transcript report to display (see config.py to configure")
	parser.add_argument("-l","--long",help="Show a detailed report of the transcript",action="store_true")
	parser.add_argument("-s","--short",help="Show a brief report of the transcript",action="store_true")
	parser.add_argument("-G","--grades",help="Include grades in the report",action="store_true")
	parser.add_argument("-C","--credit",help="Include credit/GPA information in the report",action="store_true")
	parser.add_argument("-S","--summary",help="Include a summary (program, status, etc). in the report",action="store_true")
	parser.add_argument("-f","--format",help="[TODO] Choose text format for the displayed report")
	parser.add_argument("-v", "--verbose", help="[TODO] Show details about the HTTP requests sent to Minerva",action="store_true")
	parser.set_defaults(which='transcript')


def main():
	ap = argparse.ArgumentParser()
	subp = ap.add_subparsers(help = 'Minervaclient subcommands')

	parse_reg(subp)
	parse_sched(subp)
	parse_transcript(subp)

	args = ap.parse_args()

	if args.which == 'reg':
		exec_reg(args)
	elif args.which == 'sched':
		exec_sched(args)
	elif args.which == 'transcript':
		exec_transcript(args)

def course_ref_type(arg):
	return arg[0].isalpha()

def save_state(job,data):
	global state
	f = open("/home/np/git/minervaclient/state.dat","w")
	state[job].extend(data)
	f.write(json.dumps(state))
	f.close()

def restore_state(job,courses):
	global state
	state = json.loads(open("/home/np/git/minervaclient/state.dat").read())
	if job in state:
		courses = list(set(courses) - set(state[job]))
		print courses
	else:
		state[job] = []

	return courses

def exec_reg(args):
	codes_given = course_ref_type(args.course[0])
	term = get_term_code(args.term)
	
	if credentials_local.always_dry_run:
		args.no_register = True

	if args.job is None:
		args.job = False

	for course in args.course:
		if codes_given != course_ref_type(course):
			print "\033[1;31mERROR:\033[0m Course codes cannot be combined with CRNs"
			sys.exit(MinervaError.user_error)

	
	if args.job:
		courses = restore_state(args.job,args.course)
		if not courses:
			print "\033[1;32m**** Congratulations, you've gotten into all your courses ****\033[1m"
			sys.exit(0)
	else:
		courses = args.course

	if codes_given:
		data = reg.check_register(term,courses,require_all=args.require_all,require_reg=args.require_reg,dry_run=args.no_register,public_search=args.public_search)
	else:

		if args.require_all or args.require_reg:
			print "\033[1;31mERROR:\033[0m When using CRNs, it is not possible to verify the state of classes before attempting registration."
			sys.exit(MinervaError.user_error)
		elif args.public_search:
			print "\033[1;31mERROR:\033[0m This feature is implemented only when searching by course code"
			sys.exit(MinervaErrror.user_error)

		data = reg.fast_register(term,courses,dry_run=args.no_register)

	
	# If we're still here, nothing bad happened, hopefully
	if args.job:
		save_state(args.job,data)

def exec_sched(args):
	term = get_term_code(args.term)
	
	if args.report is not None:
		report = args.report
	elif args.long:
		report = 'long'
	elif args.short:
		report = 'short'
	elif args.visual:
		report = 'timetable_default'
	elif args.calendar:
		report = 'cal_default'
	elif args.conflicts_only:
		report = 'conflicts'
	else:
		report = 'default'


	
	sched.course_details(term,report,visual=args.visual,calendar=args.calendar,conflicts_only=args.conflicts_only,no_conflicts=args.no_conflicts)


def exec_transcript(args):
	if args.term is None:
		terms = None
	else:
		terms = []
		for term in args.term.split(','):
			terms.append(get_term_code(term))


	if args.report is not None:
		report = args.report
	elif args.long:
		report = 'transcript_long'
	elif args.short:
		report = 'transcript_short'
	else:
		report = 'transcript_default'


	show = ['summary','credit','grades']
	if args.summary or args.grades or args.credit:
		show = []

	if args.summary:
		show.append('summary')
	if args.credit:
		show.append('credit')
	if args.grades:
		show.append('grades')


	transcript.get_transcript(terms,report,show)

main()


# vi: ft=python
